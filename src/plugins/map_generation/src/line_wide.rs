use crate::grid_graph::GridGraphNode;
use std::ops::RangeInclusive;

/// This adds all nodes to the graph, that would
/// be "touched" by a square (1x1) traveling down the line
/// generated by Bresenham's line algorithm.
///
/// <div class="warning">
///   Some nodes might be excluded by longer almost diagonal lines.
///   This shouldn't be a problem though, when using primarily
///   round colliders.
/// </div>
pub struct LineWide {
	orientation: Orientation,
	new_node: NewNodeFn,
	range: RangeInclusive<u32>,
}

impl LineWide {
	pub(crate) fn new(start: &GridGraphNode, end: &GridGraphNode) -> Self {
		let (low, high, new_node) = Self::normalize_layout(start, end);
		let (i_low, d_low) = match low.1 > low.0 {
			true => (1, (low.1 - low.0) as i32),
			false => (-1, (low.0 - low.1) as i32),
		};

		let orientation = match d_low {
			0 => Orientation::Straight { v_low: low.0 },
			_ => {
				let d_high = (high.1 - high.0) as i32;
				let step = Step {
					d: (2 * d_low) - d_high,
					v_lows: [low.0; 2],
					d_up: (2 * d_low) as u32,
					d_down: 2 * (d_low - d_high),
				};

				Orientation::Odd(Line {
					i_low,
					low_start: low.0,
					low_end: low.1,
					step,
					additional_nodes: [None; 3],
				})
			}
		};

		Self {
			range: high.0..=high.1,
			new_node,
			orientation,
		}
	}

	fn normalize_layout(start: &GridGraphNode, end: &GridGraphNode) -> (Low, High, NewNodeFn) {
		let dx = end.x().abs_diff(start.x());
		let dz = end.z().abs_diff(start.z());
		let is_low = dx > dz;

		match is_low {
			true if start.x() < end.x() => {
				(Low(start.z(), end.z()), High(start.x(), end.x()), Low::node)
			}
			true => (Low(end.z(), start.z()), High(end.x(), start.x()), Low::node),
			false if start.z() < end.z() => (
				Low(start.x(), end.x()),
				High(start.z(), end.z()),
				High::node,
			),
			false => (
				Low(end.x(), start.x()),
				High(end.z(), start.z()),
				High::node,
			),
		}
	}
}

impl Iterator for LineWide {
	type Item = LineNode;

	fn next(&mut self) -> Option<Self::Item> {
		match &mut self.orientation {
			Orientation::Straight { v_low } => {
				let v_high = self.range.next()?;
				let node = (self.new_node)(*v_low, v_high);
				Some(node)
			}
			Orientation::Odd(line) => match &mut line.additional_nodes {
				[node, _, _] if node.is_some() => node.take(),
				[_, node, _] if node.is_some() => node.take(),
				[_, _, node] if node.is_some() => node.take(),
				_ => {
					let high = self.range.next()?;
					let low_0 = line.step.v_lows[0];
					let low_1 = line.step.v_lows[1];
					let is_doubled = low_0 != low_1;
					let add_border = !is_doubled || line.step.steps_fast();

					let node = (self.new_node)(low_0, high);

					if add_border && low_0 != line.low_start {
						let low = low_0.checked_add_signed(-line.i_low)?;
						line.additional_nodes[0] = Some((self.new_node)(low, high));
					}

					if is_doubled {
						line.additional_nodes[1] = Some((self.new_node)(low_1, high));
					}

					if add_border && low_1 != line.low_end {
						let low = low_1.checked_add_signed(line.i_low)?;
						line.additional_nodes[2] = Some((self.new_node)(low, high));
					}

					line.step.step(line.i_low)?;

					Some(node)
				}
			},
		}
	}
}

enum Orientation {
	Straight { v_low: u32 },
	Odd(Line),
}

struct Line {
	i_low: i32,
	low_start: u32,
	low_end: u32,
	step: Step,
	additional_nodes: [Option<LineNode>; 3],
}

#[derive(Debug, PartialEq, Clone, Copy)]
#[cfg_attr(test, derive(Eq, Hash))]
pub struct LineNode {
	pub(crate) x: u32,
	pub(crate) z: u32,
}

type NewNodeFn = fn(u32, u32) -> LineNode;

struct Low(u32, u32);

impl Low {
	fn node(x: u32, z: u32) -> LineNode {
		LineNode { x: z, z: x }
	}
}

struct High(u32, u32);

impl High {
	fn node(x: u32, z: u32) -> LineNode {
		LineNode { x, z }
	}
}

#[derive(Debug, PartialEq)]
struct Step {
	d: i32,
	v_lows: [u32; 2],
	d_up: u32,
	d_down: i32,
}

impl Step {
	#[must_use]
	fn step(&mut self, i_low: i32) -> Option<()> {
		if self.d < 0 {
			self.d += self.d_up as i32;
			return Some(());
		}

		if self.d == 0 {
			self.d += self.d_up as i32;
			self.v_lows[1] = self.v_lows[1].checked_add_signed(i_low)?;
			return Some(());
		}

		self.v_lows[0] = self.v_lows[0].checked_add_signed(i_low)?;
		self.v_lows[1] = self.v_lows[0];
		self.d += self.d_down;

		Some(())
	}

	fn steps_fast(&self) -> bool {
		self.d_down.unsigned_abs() < self.d_up
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use std::collections::HashSet;
	use test_case::test_case;

	fn line_end(x: u32, z: u32) -> GridGraphNode {
		GridGraphNode::new(x, z)
	}

	#[test_case(line_end(1, 0), line_end(3, 0), [(1, 0), (2, 0), (3, 0)]; "x aligned")]
	#[test_case(line_end(0, 1), line_end(0, 3), [(0, 1), (0, 2), (0, 3)]; "z aligned")]
	#[test_case(line_end(1, 4), line_end(3, 4), [(1, 4), (2, 4), (3, 4)]; "x aligned with non zero z")]
	fn straight<const N: usize>(start: GridGraphNode, end: GridGraphNode, nodes: [(u32, u32); N]) {
		assert_eq!(
			HashSet::from(nodes.map(|(x, z)| LineNode { x, z })),
			LineWide::new(&start, &end).collect::<HashSet<_>>()
		)
	}

	#[test_case(line_end(1, 1), line_end(3, 3), [(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 2), (3, 3)]; "ascending")]
	#[test_case(line_end(3, 3), line_end(1, 1), [(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 2), (3, 3)]; "ascending reversed")]
	#[test_case(line_end(1, 3), line_end(3, 1), [(1, 3), (1, 2), (2, 3), (2, 2), (2, 1), (3, 2), (3, 1)]; "descending")]
	#[test_case(line_end(3, 1), line_end(1, 3), [(1, 3), (1, 2), (2, 3), (2, 2), (2, 1), (3, 2), (3, 1)]; "descending reversed")]
	fn diagonal<const N: usize>(start: GridGraphNode, end: GridGraphNode, nodes: [(u32, u32); N]) {
		assert_eq!(
			HashSet::from(nodes.map(|(x, z)| LineNode { x, z })),
			LineWide::new(&start, &end).collect::<HashSet<_>>()
		)
	}

	#[test_case(line_end(1, 1), line_end(3, 2), [(1, 1), (1, 2), (2, 1), (2, 2), (3, 1), (3, 2)]; "low")]
	#[test_case(line_end(1, 1), line_end(2, 3), [(1, 1), (2, 1), (1, 2), (2, 2), (1, 3), (2, 3)]; "high")]
	fn draws_rectangle<const N: usize>(
		start: GridGraphNode,
		end: GridGraphNode,
		nodes: [(u32, u32); N],
	) {
		assert_eq!(
			HashSet::from(nodes.map(|(x, z)| LineNode { x, z })),
			LineWide::new(&start, &end).collect::<HashSet<_>>()
		)
	}

	#[test_case(line_end(1, 1), line_end(4, 3), [(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 2), (4, 3)]; "low")]
	#[test_case(line_end(4, 3), line_end(1, 1), [(1, 1), (1, 2), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3), (4, 2), (4, 3)]; "low reversed")]
	#[test_case(line_end(1, 1), line_end(3, 4), [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4)]; "high")]
	#[test_case(line_end(3, 4), line_end(1, 1), [(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4)]; "high reversed")]
	fn odd<const N: usize>(start: GridGraphNode, end: GridGraphNode, nodes: [(u32, u32); N]) {
		assert_eq!(
			HashSet::from(nodes.map(|(x, z)| LineNode { x, z })),
			LineWide::new(&start, &end).collect::<HashSet<_>>()
		)
	}
}
