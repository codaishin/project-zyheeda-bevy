use crate::grid_graph::GridGraphNode;
use std::ops::RangeInclusive;

/// This adds all nodes to the graph, that would
/// be "touched" by a square (1x1) traveling down the line
/// generated by Bresenham's line algorithm.
///
/// <div class="warning">
///   Some nodes might be excluded by longer almost diagonal lines.
///   This shouldn't be a problem though, when using primarily
///   round colliders.
/// </div>
pub struct LineWide {
	orientation: Orientation,
	new_node: NewNodeFn,
	range: RangeInclusive<usize>,
}

impl LineWide {
	pub(crate) fn new(start: &GridGraphNode, end: &GridGraphNode) -> Self {
		let (low, high, new_node) = Self::normalize_layout(start, end);
		let (i_low, d_low) = match low.1 > low.0 {
			true => (1, (low.1 - low.0) as isize),
			false => (-1, (low.0 - low.1) as isize),
		};

		let orientation = match d_low {
			0 => Orientation::Straight { v_low: low.0 },
			_ => {
				let d_high = (high.1 - high.0) as isize;
				let step = Step {
					d: (2 * d_low) - d_high,
					v_lows: [low.0; 2],
					d_up: (2 * d_low) as usize,
					d_down: 2 * (d_low - d_high),
				};

				Orientation::Odd(Line {
					i_low,
					low_start: low.0,
					low_end: low.1,
					step,
					additional_nodes: [None; 3],
				})
			}
		};

		Self {
			range: high.0..=high.1,
			new_node,
			orientation,
		}
	}

	fn normalize_layout(start: &GridGraphNode, end: &GridGraphNode) -> (Low, High, NewNodeFn) {
		let dx = end.x().abs_diff(start.x());
		let dz = end.z().abs_diff(start.z());
		let is_low = dx > dz;

		match is_low {
			true if start.x() < end.x() => {
				(Low(start.z(), end.z()), High(start.x(), end.x()), Low::node)
			}
			true => (Low(end.z(), start.z()), High(end.x(), start.x()), Low::node),
			false if start.z() < end.z() => (
				Low(start.x(), end.x()),
				High(start.z(), end.z()),
				High::node,
			),
			false => (
				Low(end.x(), start.x()),
				High(end.z(), start.z()),
				High::node,
			),
		}
	}
}

impl Iterator for LineWide {
	type Item = LineNode;

	fn next(&mut self) -> Option<Self::Item> {
		match &mut self.orientation {
			Orientation::Straight { v_low } => {
				let v_high = self.range.next()?;
				let node = (self.new_node)(*v_low, v_high);
				Some(node)
			}
			Orientation::Odd(line) => match &mut line.additional_nodes {
				[node, _, _] if node.is_some() => node.take(),
				[_, node, _] if node.is_some() => node.take(),
				[_, _, node] if node.is_some() => node.take(),
				_ => {
					let high = self.range.next()?;
					let low_0 = line.step.v_lows[0];
					let low_1 = line.step.v_lows[1];
					let is_doubled = low_0 != low_1;
					let add_border = !is_doubled || line.step.steps_fast();

					let node = (self.new_node)(low_0, high);

					if add_border && low_0 != line.low_start {
						let low = low_0.checked_add_signed(-line.i_low)?;
						line.additional_nodes[0] = Some((self.new_node)(low, high));
					}

					if is_doubled {
						line.additional_nodes[1] = Some((self.new_node)(low_1, high));
					}

					if add_border && low_1 != line.low_end {
						let low = low_1.checked_add_signed(line.i_low)?;
						line.additional_nodes[2] = Some((self.new_node)(low, high));
					}

					line.step.step(line.i_low)?;

					Some(node)
				}
			},
		}
	}
}

enum Orientation {
	Straight { v_low: usize },
	Odd(Line),
}

struct Line {
	i_low: isize,
	low_start: usize,
	low_end: usize,
	step: Step,
	additional_nodes: [Option<LineNode>; 3],
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub struct LineNode {
	pub(crate) x: usize,
	pub(crate) z: usize,
}

type NewNodeFn = fn(usize, usize) -> LineNode;

struct Low(usize, usize);

impl Low {
	fn node(x: usize, z: usize) -> LineNode {
		LineNode { x: z, z: x }
	}
}

struct High(usize, usize);

impl High {
	fn node(x: usize, z: usize) -> LineNode {
		LineNode { x, z }
	}
}

#[derive(Debug, PartialEq)]
struct Step {
	d: isize,
	v_lows: [usize; 2],
	d_up: usize,
	d_down: isize,
}

impl Step {
	#[must_use]
	fn step(&mut self, i_low: isize) -> Option<()> {
		if self.d < 0 {
			self.d += self.d_up as isize;
			return Some(());
		}

		if self.d == 0 {
			self.d += self.d_up as isize;
			self.v_lows[1] = self.v_lows[1].checked_add_signed(i_low)?;
			return Some(());
		}

		self.v_lows[0] = self.v_lows[0].checked_add_signed(i_low)?;
		self.v_lows[1] = self.v_lows[0];
		self.d += self.d_down;

		Some(())
	}

	fn steps_fast(&self) -> bool {
		self.d_down.unsigned_abs() < self.d_up
	}
}
